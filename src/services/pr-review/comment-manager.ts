import { ReviewComment } from '../../types.js';
import { logger } from '../../utils/logger.js';
import { ExistingComment, CommentValidationResult, LLMAnalysisResult } from './types.js';

/**
 * Comment Management Module
 *
 * Handles comment validation, deduplication, and conversion from LLM analysis
 * to GitHub review comments.
 */

/**
 * Check if a comment is similar to existing comments to avoid duplicates
 */
export function isDuplicateComment(
  newComment: ReviewComment,
  existingComments: ExistingComment[]
): boolean {
  for (const existing of existingComments) {
    // Check for exact path and line match
    if (existing.path === newComment.path && existing.line === newComment.line) {
      // Check if the comment is from our AI (has the signature)
      if (existing.body.includes('ü§ñ Generated by Migaki AI')) {
        logger.info('Skipping duplicate AI comment', {
          path: newComment.path,
          line: newComment.line,
        });
        return true;
      }

      // Check for similar content (simple similarity check)
      const existingWords = existing.body.toLowerCase().split(/\s+/);
      const newWords = newComment.body.toLowerCase().split(/\s+/);
      const commonWords = existingWords.filter((word) => newWords.includes(word));
      const similarity = commonWords.length / Math.max(existingWords.length, newWords.length);

      // If more than 60% similar, consider it a duplicate
      if (similarity > 0.6) {
        logger.info('Skipping similar comment', {
          path: newComment.path,
          line: newComment.line,
          similarity: Math.round(similarity * 100) + '%',
        });
        return true;
      }
    }
  }

  return false;
}

/**
 * Filter out duplicate comments
 */
export function filterDuplicateComments(
  comments: ReviewComment[],
  existingComments: ExistingComment[]
): ReviewComment[] {
  const filteredComments = comments.filter(
    (comment) => !isDuplicateComment(comment, existingComments)
  );

  const duplicatesRemoved = comments.length - filteredComments.length;
  if (duplicatesRemoved > 0) {
    logger.info('Filtered out duplicate comments', {
      original: comments.length,
      filtered: filteredComments.length,
      duplicatesRemoved,
    });
  }

  return filteredComments;
}

/**
 * Convert LLM analysis into review comments with GitHub diff positions
 */
export function convertAnalysisToComments(
  analysis: LLMAnalysisResult['issues'],
  filePath: string,
  lineToPositionMap: Map<number, number>
): ReviewComment[] {
  if (!Array.isArray(analysis)) {
    return [];
  }

  return analysis
    .filter((item) => item && typeof item === 'object')
    .map((item) => {
      const severityEmoji = {
        critical: 'üî¥',
        warning: 'üü°',
        info: 'üîµ',
      };

      const categoryLabel = {
        security: 'Security',
        bug: 'Bug',
        performance: 'Performance',
        maintainability: 'Code Quality',
      };

      const emoji = severityEmoji[item.severity as keyof typeof severityEmoji] || '‚ö†Ô∏è';
      const category = categoryLabel[item.category as keyof typeof categoryLabel] || 'General';

      let body = `${emoji} **${category}**: ${item.message || 'Issue detected'}`;

      if (item.suggestion) {
        body += `\n\nüí° **Suggestion**: ${item.suggestion}`;
      }

      if (item.explanation) {
        body += `\n\nüìù **Why this matters**: ${item.explanation}`;
      }

      // Add AI signature
      body += '\n\n---\n*ü§ñ Generated by Migaki AI*';

      // Get the GitHub diff position for this line
      const diffPosition = lineToPositionMap.get(item.line || 1);

      if (!diffPosition) {
        logger.warn('No diff position found for line, comment may be skipped', {
          filePath,
          line: item.line,
          availablePositions: Array.from(lineToPositionMap.keys()).slice(0, 5),
        });
      }

      return {
        path: filePath,
        line: item.line || 1,
        position: diffPosition, // GitHub diff position
        body,
        severity: (['info', 'warning', 'critical'].includes(item.severity)
          ? item.severity === 'critical'
            ? 'error'
            : item.severity
          : 'info') as 'info' | 'warning' | 'error',
        category: item.category || 'general',
        suggestion: item.suggestion,
      };
    })
    .filter((comment) => comment.position !== undefined); // Only include comments with valid positions
}

/**
 * Validate that all comments have valid line numbers for GitHub PR review
 */
export function validateCommentsForGitHub(
  comments: ReviewComment[],
  fileValidDiffLines?: Map<string, Set<number>>
): CommentValidationResult {
  const validComments: ReviewComment[] = [];
  const invalidComments: Array<{ comment: ReviewComment; reason: string }> = [];

  for (const comment of comments) {
    // Basic validation
    if (!comment.path || typeof comment.path !== 'string') {
      invalidComments.push({ comment, reason: 'Missing or invalid path' });
      continue;
    }

    if (!comment.line || typeof comment.line !== 'number' || comment.line < 1) {
      invalidComments.push({ comment, reason: 'Missing or invalid line number' });
      continue;
    }

    if (!comment.body || typeof comment.body !== 'string' || comment.body.trim() === '') {
      invalidComments.push({ comment, reason: 'Missing or empty body' });
      continue;
    }

    // Validate against diff lines if available
    if (fileValidDiffLines) {
      const validLines = fileValidDiffLines.get(comment.path);
      if (validLines && !validLines.has(comment.line)) {
        invalidComments.push({
          comment,
          reason: `Line ${comment.line} is not part of the diff for file ${comment.path}`,
        });
        continue;
      }
    }

    validComments.push(comment);
  }

  return { validComments, invalidComments };
}

/**
 * Generate a review summary
 */
export function generateReviewSummary(comments: ReviewComment[]): string {
  const criticalCount = comments.filter((c) => c.severity === 'error').length;
  const warningCount = comments.filter((c) => c.severity === 'warning').length;
  const infoCount = comments.filter((c) => c.severity === 'info').length;

  let summary = `## üîç Code Review Summary\n\n`;
  summary += `I've analyzed your pull request and found ${comments.length} item(s) for your consideration:\n\n`;

  if (criticalCount > 0) {
    summary += `- üö® **${criticalCount} Critical issue(s)** that should be addressed\n`;
  }
  if (warningCount > 0) {
    summary += `- ‚ö†Ô∏è **${warningCount} Warning(s)** worth reviewing\n`;
  }
  if (infoCount > 0) {
    summary += `- ‚ÑπÔ∏è **${infoCount} Suggestion(s)** for improvement\n`;
  }

  summary += `\nPlease review the inline comments for details. Each comment includes specific suggestions for improvement.`;

  if (criticalCount === 0) {
    summary += `\n\n‚úÖ No critical issues detected. Great work!`;
  }

  return summary;
}
